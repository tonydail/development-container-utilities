#!/bin/bash

SCRIPT_PATH=$(dirname "$0") #the directory of this script
BACK_TITLE="Development Container Template Manager"

CURRENT_DIR="$PWD" #where this is executed from
CONTAINER_PREFIX=$(basename "$CURRENT_DIR") #the container prefix is the name of the folder

TEMPLATES_DIR="$SCRIPT_PATH/src/templates"
COMMON_TEMPLATES_DIR="$SCRIPT_PATH/src/common"

CONCATENATIONS_DIR="merges"
DEVCONTAINER_UPDATES_DIR="devcontainer-updates"



DEV_CONTAINER_JSON_NAME="devcontainer.json"
DEVCONTAINER_INIT_SCRIPT_NAME="host-init.sh"
DEVCONTAINER_POST_CREATE_SCRIPT_NAME="container-post-create.sh"
DOCKER_COMPOSE_FILE_NAME="docker-compose.yaml"
DOCKER_COMPOSE_OVERRIDE_FILE_NAME="docker-compose-overrides.yaml"
BASH_ALIAS_FILE_NAME=".bash_aliases"
CONTAINER_FEATURES_FILE_NAME="container-features.json"
VSCODE_EXTENSIONS_FILE_NAME="vscode-extensions.json"
UNISON_SYNC_EXCLUDES_FILE_NAME="unison-sync-excludes"
ENVIRONMENT_FILE_NAME=".env"



get_temp_file() {
    if ! temp_file=$(mktemp /tmp/temp_file.XXXXXX); then
        echo ""
    else
        echo "$temp_file"
    fi
}

get_temp_directory() {
   if ! tmpDir=$(mktemp -d -t temp_directory.XXXXXX); then
        echo ""
   else
        echo "$tmpDir"
   fi
}

# Usage 
# result=$(ensure_file "<file_path>" <create_if_missing> = true/false - can be omitted)
ensure_file() {
    local file_path="$1"
    local create_if_missing="$2"
    
    if [ ! -f "$file_path" ]; then
        if [ "$create_if_missing" = true ]; then
            touch "$file_path"
        fi
    fi

    if [ ! -f "$file_path" ]; then
        return 1
    else
        return 0
    fi
}

ensure_directory() {
  local dir_path="$1"
  local create_if_missing="$2"
    
    if [ ! -d "$dir_path" ]; then
        if [ "$create_if_missing" = true ]; then
            mkdir "$dir_path"
        fi
    fi

    if [ ! -d "$dir_path" ]; then
        return 1
    else
        return 0
    fi
}


writeEnvironmentComment() {
    local comment="$1"
    local file_path="$2"
    
    if ensure_file "$file_path" true; then
      printf "\n\n# %s" "$comment" >> "$ENVIRONMENT_FILE" || die "Failed to write comment to $ENVIRONMENT_FILE"
    fi
}

writeEnvironmentFileEntry() {
  local var_name="$1"
  local var_value="$2"
  local file_path="$3"
  
  if ensure_file "$file_path" true; then
    if grep -q "^${var_name}=" "$file_path" 2>/dev/null; then
      # Update existing variable
      sed -i'' "s/^${var_name}=.*/${var_name}=${var_value}/" "$file_path" || die "Failed to update $var_name in $file_path"
    else
      # Add new variable
      printf "\n" >> "$file_path"  # Ensure there's a newline before appending
      echo "${var_name}=${var_value}" >> "$file_path" || die "Failed to add $var_name to $file_path"
    fi
  fi
}

writeUnisonExcludesToEnvironmentFile() {
    if ensure_file "$EXCLUDES_FILE" false; then
        local EXCLUDES=()
  
        # read non-empty non-comment lines
        while IFS= read -r line; do
        line="${line%%#*}" # strip comments
        line="$(echo "$line" | xargs)" # trim
        [ -n "$line" ] && EXCLUDES+=("$line")
        done < "$EXCLUDES_FILE"

        local exclude_args="${EXCLUDES[*]:-}"
        writeEnvironmentComment "Unison sync excludes" "$ENVIRONMENT_FILE"
        writeEnvironmentFileEntry "UNISON_EXCLUDES" "\"$exclude_args\"" "$ENVIRONMENT_FILE"
        rm -f "$EXCLUDES_FILE"
    fi
}

update_devcontainer_features() {
    local features_file="$1"
    local input_file="$2"
    local output_file="$3"
    
    if [ -f "$features_file" ]; then
        if ! jq --slurpfile f "$features_file" '.features = ($f[0].features // $f[0])' "$input_file" > "$output_file"; then
        echo "jq failed" >&2
        exit 7
        fi      
    fi
}

update_devcontainer_extensions() {
    local extensions_file="$1"
    local input_file="$2"
    local output_file="$3"
    
    if [ -f "$extensions_file" ]; then
        if ! jq --slurpfile ext "$extensions_file" '(.customizations //= {}) | (.customizations.vscode //= {}) | .customizations.vscode.extensions = $ext[0]' "$input_file" > "$output_file"; then
            echo "jq failed" >&2
            exit 7
        fi
    fi
}

update_devcontainer_json() {
    temp_dir="$1"
    feature_dir="$2"
    #life cycle events
    event_names=("initializeCommand" "onCreateCommand" "updateContentCommand" "postCreateCommand" "postStartCommand" "postAttachCommand")
    event_scripts=("host-init.sh" "container-create.sh" "container-update-content.sh" "container-post-create.sh" "container-post-start.sh" "container-post-attach.sh")
    for i in "${!event_names[@]}"; do
        echo "${event_names[$i]}=${event_scripts[$i]}" >> lifecycleevents
    done

}

merge_files() {
    local srcFolder="$1"
    local destinationFolder="$2"
 
    shopt -s dotglob # we want the hidden files too
    local files_array=("$srcFolder"/*)

    rm -f filestoconcat
    for file in "${files_array[@]}"; do
        destination_file="$destinationFolder/$(basename "$file")"
        ensure_file "$destination_file" true
        printf "\n" >> "$destination_file"
        cat "$file" >> "$destination_file"
        printf "\n%s -> %s" "$file" "$destination_file" >> filestoconcat
    done

    shopt -u dotglob #reset hidden files listing

}

cleanup_containers_by_prefix() {
  local PREFIX="$1"

  if [ -z "$PREFIX" ]; then
    echo "Usage: cleanup_by_prefix <container_name_prefix>"
    return 1
  fi

  # Find containers whose names begin with the prefix
  local CONTAINERS
  CONTAINERS=$(docker ps -a --format "{{.ID}} {{.Names}}" | awk -v p="$PREFIX" '$2 ~ "^"p {print $1}')

  if [ -z "$CONTAINERS" ]; then
    echo "No containers found with names beginning with: $PREFIX"
    return 0
  fi

    for CONTAINER in $CONTAINERS; do
       # Check if container still exists
        if ! docker ps -a --format '{{.ID}}' | grep -q "^$CONTAINER$"; then
        echo "Container $CONTAINER does not exist, skipping."
        continue
        fi

        # Stop the container if it is running
        if docker ps --format '{{.ID}}' | grep -q "^$CONTAINER$"; then
        echo "Stopping running container: $CONTAINER"
        docker stop "$CONTAINER"
        fi
    done

  # Stop running containers
  for CONTAINER in $CONTAINERS; do
    # Check if container still exists
    if ! docker ps -a --format '{{.ID}}' | grep -q "^$CONTAINER$"; then
      echo "Container $CONTAINER does not exist, skipping."
      continue
    fi

    # Stop the container if it is running
    if docker ps --format '{{.ID}}' | grep -q "^$CONTAINER$"; then
      echo "Stopping running container: $CONTAINER"
      docker stop "$CONTAINER"
    fi
  done

  # Remove containers, images, networks, and volumes
  for CONTAINER in $CONTAINERS; do
    # Check if container still exists
    if ! docker ps -a --format '{{.ID}}' | grep -q "^$CONTAINER$"; then
      echo "Container $CONTAINER does not exist, skipping."
      continue
    fi

    # Get image ID
    local IMAGE_ID
    IMAGE_ID=$(docker inspect --format='{{.Image}}' "$CONTAINER")
    # Get user-defined networks (skip default ones)
    local NETWORKS
    NETWORKS=$(docker inspect --format='{{range $k, $v := .NetworkSettings.Networks}}{{if not (or (eq $k "bridge") (eq $k "host") (eq $k "none"))}}{{$k}} {{end}}{{end}}' "$CONTAINER")
    # Get attached volumes
    local VOLUMES
    VOLUMES=$(docker inspect --format='{{range .Mounts}}{{if eq .Type "volume"}}{{.Name}} {{end}}{{end}}' "$CONTAINER")

    echo "Removing container: $CONTAINER"
    docker rm -f "$CONTAINER"

    # Check and remove image
    if [ -n "$IMAGE_ID" ] && docker images -a --no-trunc --format '{{.ID}}' | grep -q "^$IMAGE_ID$"; then
      echo "Removing image: $IMAGE_ID"
      docker rmi -f "$IMAGE_ID"
    else
      echo "Image $IMAGE_ID does not exist or already removed."
    fi

    # Check and remove networks
    for NET in $NETWORKS; do
      if docker network ls --format '{{.Name}}' | grep -q "^$NET$"; then
        echo "Removing network: $NET"
        docker network rm "$NET"
      else
        echo "Network $NET does not exist or already removed."
      fi
    done

    # Check and remove volumes
    for VOL in $VOLUMES; do
      if docker volume ls --format '{{.Name}}' | grep -q "^$VOL$"; then
        echo "Removing volume: $VOL"
        docker volume rm "$VOL"
      else
        echo "Volume $VOL does not exist or already removed."
      fi
    done
  done
}

apply_template() {
    # List template directories
    TEMPLATES=()
    for dir in "$TEMPLATES_DIR"/*/; do
        [ -d "$dir" ] || continue
        name=$(basename "$dir")
        TEMPLATES+=("$name" "")
    done

    if [ ${#TEMPLATES[@]} -eq 0 ]; then
        dialog --msgbox "No templates found." 6 40
        return
    fi

    TEMPLATE=$(dialog --clear --backtitle "$BACK_TITLE" \
        --title "Select Template" \
        --menu "Choose a template:" 15 50 6 \
        "${TEMPLATES[@]}" \
        2>&1 >/dev/tty)

    [ -z "$TEMPLATE" ] && return

    # Folder selection dialog
    DEST=$(dialog --backtitle "$BACK_TITLE" --dselect "$CURRENT_DIR/" 10 60 2>&1 >/dev/tty)
    [ -z "$DEST" ] && return


    if dialog --yesno  "Template '$TEMPLATE' will be applied to '$DEST'.\nDo you want to continue?" 7 80; then

        if [ ! -d "$COMMON_TEMPLATES_DIR" ]; then
            dialog --msgbox "$COMMON_TEMPLATES_DIR not found!" 6 60
            return
        fi

        if [ ! -d "$TEMPLATES_DIR/$TEMPLATE" ]; then
            dialog --msgbox "$TEMPLATES_DIR/$TEMPLATE not found!" 6 60
            return
        fi

        if [ ! -d "$DEST" ]; then
            dialog --msgbox "The selected destination is not a valid directory." 6 60
            return
        else
            if  ! mkdir -p "$DEST/.devcontainer" 
            then
                dialog --msgbox "Unable to create .devcontainer folder." 6 60
                return
            else
                ls "$DEST/.devcontainer"
            fi
        fi

        local canproceed=true
        if [ "$(ls -A $DEST.devcontainer)" ]; then
            if dialog  --yesno "$DEST/.devcontainer is not empty. Do you want to overwrite its contents?" 7 80; then
                rm -rf "$DEST/.devcontainer" 2>/dev/null         
            else
                canproceed=false
            fi
        fi

        
        if [ "$canproceed" = true ]; then
              
            #create temporary working folder and files
            tmpDir=$(get_temp_directory)
            if ! ensure_directory "$tmpDir" false
            then
                dialog --msgbox "Could not create $tmpDir" 6 60
                exit
            fi


            tmpfile1=$(get_temp_file)
            if ! ensure_file "$tmpfile1" false
            then
                dialog --msgbox "Could not create $tmpfile1" 6 60
                exit
            fi

            tmpfile2=$(get_temp_file)
            if ! ensure_file "$tmpfile2" false
            then
                dialog --msgbox "Could not create $tmpfile2" 6 60
                exit
            fi

            echo "$tmpDir" > templocation
            #copy the template files to the temporary directory
            cp -af $COMMON_TEMPLATES_DIR/. "$tmpDir/" 2>/dev/null

            ensure_directory "$tmpDir/$TEMPLATE" true
            cp -af $TEMPLATES_DIR/$TEMPLATE/. "$tmpDir/$TEMPLATE" 2>/dev/null

            merge_files "$tmpDir/$TEMPLATE/$CONCATENATIONS_DIR" "$tmpDir"
            update_devcontainer_json "$temp_dir" "$TEMPLATE"
            exit

            FEATURES_FILE="$tmpDir/$CONTAINER_FEATURES_FILE_NAME"
            EXTENSION_FILE="$tmpDir/$VSCODE_EXTENSIONS_FILE_NAME"
            DEVFILE="$tmpDir/$DEV_CONTAINER_JSON_NAME"
            FINISHEDFILE="$tmpDir/$DEV_CONTAINER_JSON_NAME"
            ENVIRONMENT_FILE="$tmpDir/$ENVIRONMENT_FILE_NAME"
            EXCLUDES_FILE="$tmpDir/$UNISON_SYNC_EXCLUDES_FILE_NAME"

            TEMPFILETOCOPY=

            if [ -f "$FEATURES_FILE" ]; then
                if update_devcontainer_features "$FEATURES_FILE" "$DEVFILE" "$tmpfile1"; then
                  TEMPFILETOCOPY="$tmpfile1"
                fi
            fi


            if [ -f "$EXTENSION_FILE" ]; then
               if update_devcontainer_extensions "$EXTENSION_FILE" "${TEMPFILETOCOPY:-$DEVFILE}" "$tmpfile2"; then
                  TEMPFILETOCOPY="$tmpfile2"
               fi
            fi

            mv -f "$TEMPFILETOCOPY" "$FINISHEDFILE"  
            rm -f "$FEATURES_FILE" "$EXTENSION_FILE" "$tmpfile1" "$tmpfile2"

            writeUnisonExcludesToEnvironmentFile 
        
            echo "$tmpDir" > "templocation"
            exit
            
            if [ ! -d "$DEST/.devcontainer" ]; then
                mkdir -p "$DEST.devcontainer"
            fi

            if ! cp -af "$tmpDir/." "$DEST.devcontainer/" 2>/dev/null; then
                dialog --msgbox "Failed to copy files to $DEST.devcontainer" 6 60
                return
            fi
            rm -rf "$tmpDir"

            dialog --msgbox "Template '$TEMPLATE' applied successfully to '$DEST/.devcontainer'." 6 60
        fi
    fi
}

reset_docker_environment() {

    CONTAINER_PREFIX=$(basename "$CURRENT_DIR")

    if dialog --yesno  "This will remove all Docker containers, images, volumes, and networks associated with $CONTAINER_PREFIX .\nDo you want to continue?" 7 80; then
        cleanup_containers_by_prefix "$CONTAINER_PREFIX"
        if dialog --yesno  "Delete base containers and images?" 7 80; then
            lowercase_container_prefix=$(echo "$CONTAINER_PREFIX" | tr '[:upper:]' '[:lower:]')
            cleanup_containers_by_prefix "$lowercase_container_prefix"
        fi
        
        dialog --msgbox "Docker environment reset successfully." 6 60
    fi
}

main_menu() {
    while true; do
        CHOICE=$(dialog --clear --backtitle "$BACK_TITLE" \
            --title "Main Menu" \
            --menu "Choose an action:" 15 80 4 \
            1 "Apply Template to $CONTAINER_PREFIX" \
            2 "Save as a Template" \
            3 "Delete Template" \
            4 "Cleanup docker environment for $CONTAINER_PREFIX" \
            5 "Exit" \
            2>&1 >/dev/tty)

        case $CHOICE in
            1)
                apply_template
                ;;
            2)
                dialog --msgbox "Save Template selected." 6 40
                ;;
            3)
                dialog --msgbox "Delete Template selected." 6 40
                ;;
            4)
                reset_docker_environment
                ;;
            5)
                clear
                break
                ;;
        esac
    done
}

main_menu